(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{217:function(v,e,_){"use strict";_.r(e);var r=_(0),i=Object(r.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("处理分发需求,毁掉,事件,订阅发布比较合适"),_("br"),v._v("\n处理流程性质的需求promise和generator比较合适"),_("br"),v._v("\nrxjs结合了两种模式"),_("br"),v._v("\n我们可以把一切的输入当做流来处理")]),v._v(" "),_("ul",[_("li",[v._v("用户操作")]),v._v(" "),_("li",[v._v("网络响应")]),v._v(" "),_("li",[v._v("定时器")]),v._v(" "),_("li",[v._v("worker"),_("br"),v._v("\nRxjs 提供了各种api来创建数据流")]),v._v(" "),_("li",[v._v("单值: of, empty, never")]),v._v(" "),_("li",[v._v("多值: from")]),v._v(" "),_("li",[v._v("定时: interval,timer")]),v._v(" "),_("li",[v._v("从事件创建:fromEvent")]),v._v(" "),_("li",[v._v("从promise创建:fromPromise")]),v._v(" "),_("li",[v._v("自定义创建: create"),_("br"),v._v("\n创建出来的数据流是一种可观察的序列,可以被订阅,可以做一些转换操作")]),v._v(" "),_("li",[v._v("改变数据的形态: map, mapTo, pluck")]),v._v(" "),_("li",[v._v("过滤一些值:filter,skip, first, lost, take")]),v._v(" "),_("li",[v._v("时间轴上的操作: delay, timeout, throttle, debounce,  audit, bufferTime")]),v._v(" "),_("li",[v._v("累加: reduce, scan")]),v._v(" "),_("li",[v._v("异常处理: throw, catch, retry, finally")]),v._v(" "),_("li",[v._v("条件执行: takeUntil, delayWhen, retryWhen, subscribeOn, observeOn")]),v._v(" "),_("li",[v._v("转接: switch"),_("br"),v._v("\n也可以对若干个数据流进行组合")]),v._v(" "),_("li",[v._v("concat: 保持原来的序列顺序连接两个数据流")]),v._v(" "),_("li",[v._v("merge: 合并序列")]),v._v(" "),_("li",[v._v("race: 预设条件为其中一个数据流完成")]),v._v(" "),_("li",[v._v("forkJoin: 预设条件为所有数据流完成")]),v._v(" "),_("li",[v._v("zip: 取个来源数据最后一个值合并为对象")]),v._v(" "),_("li",[v._v("combinelatest: 取个来源数据最后一个值合并为数组"),_("br"),v._v("\nobservable: 可观察序列,只出不进"),_("br"),v._v("\nObserver:观察者,只进不出"),_("br"),v._v("\nSubject: 可进可出可观察序列,可作为观察者"),_("br"),v._v("\nSubscribtion: 订阅关系,取消订阅")])])])}),[],!1,null,null,null);e.default=i.exports}}]);